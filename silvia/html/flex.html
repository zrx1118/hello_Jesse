<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <link rel="stylesheet" href="../assets/css/normalize.css">
    <style>
        body{background: #f06d06; font-size: 80%;position: relative;}
        .outer{
            text-align: center;
        }
        .center{
            margin: 0 auto;
            width: 200px;
            background: black;
            padding: 20px;
            color: white;
        }
        main,section{background: white; margin: 20px 0; padding: 10px;}
        section div{background: black; color: white; padding: 15px; margin: 5px auto;}
        section div:nth-child(1){width: 200px;}
        section div:nth-child(2){width: 400px;}
        section div:nth-child(3){width: 125px;}
        main div{background: black; color: white; padding: 15px; max-width: 125px; margin: 5px;}
        .inline-block-center{text-align: center;}
        .inline-block-center div{display: inline-block; text-align: left;}
        .flex-center{display: flex; justify-content: center;}
        .flex-ctr{background: white;width: 240px;margin: 20px;}
        .flex-ctr{background: black;color: white;border: 10px solid white;display: flex;flex-direction: column;justify-content: center;height: 200px;overflow: auto;resize :vertical;}
        .flex-ctr p{margin: 0; padding: 20px;}
        /* .ghost-center {position: relative;}
        .ghost-center::before {content: " ";display: inline-block;width: 1%;height: 100%;vertical-align: middle;}
        .ghost-center p {display: inline-block;vertical-align: middle;} */
    </style>
</head>
<body>
    <p>设为Flex布局以后，子元素的float、clear和vertical-align属性将失效</p>
    <img src="http://www.runoob.com/wp-content/uploads/2015/07/3791e575c48b3698be6a94ae1dbff79d.png" alt="">
    <p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>

    <p>容器的属性：
        <ul>
            <li>flex-direction  (row | row-reverse水平) | (column | column-reverse垂直);</li>
            <li>
                flex-wrap nowrap | wrap | wrap-reverse;
                <div style="width: 26px; display: flex; flex-wrap: wrap-reverse; "><p>1</p><p>2</p><p>3</p><p>4</p></div>
            </li>
            <li>
                flex-flow 属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。
                <div>
                    .box {
                        flex-flow: flex-direction flex-wrap;
                    }
                </div>
            </li>
            <li>
                justify-content属性定义了项目在主轴上的对齐方式。
                <div>
                    flex-start（默认值）：左对齐
                    flex-end：右对齐
                    center： 居中
                    space-between：两端对齐，项目之间的间隔都相等。
                    space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
                </div>
            </li>
            <li>
                align-items属性定义项目在交叉轴上如何对齐。
                <div>
                    flex-start：交叉轴的起点对齐。
                    flex-end：交叉轴的终点对齐。
                    center：交叉轴的中点对齐。
                    baseline: 项目的第一行文字的基线对齐。
                    stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度
                </div>
            </li>
            <li>
                align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
                <div>
                    flex-start：与交叉轴的起点对齐。
                    flex-end：与交叉轴的终点对齐。
                    center：与交叉轴的中点对齐。
                    space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
                    space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
                    stretch（默认值）：轴线占满整个交叉轴。
                </div>
            </li>
        </ul>
    </p>
    <div class="outer">
        <div class="inner">I'm a block level element and am centered.</div>
    </div>
    <div class="center">I'm a block level element and am centered.</div>
    <main class="inline-block-center">
        <div>I'm an element that is block-like with my siblings and we're centered in a row.</div>
        <div>I'm an element that is block-like with my siblings and we're centered in a row. I have more content in me than my siblings do.</div>
        <div>I'm an element that is block-like with my siblings and we're centered in a row.</div>
    </main>
    <main class="flex-center">
        <div>I'm an element that is block-like with my siblings and we're centered in a row.</div>
        <div>I'm an element that is block-like with my siblings and we're centered in a row. I have more content in me than my siblings do.</div>
        <div>I'm an element that is block-like with my siblings and we're centered in a row.</div>
    </main>
    <section>
        <div>I'm an element that is block-like with my siblings and we're centered in a row.</div>
        <div>I'm an element that is block-like with my siblings and we're centered in a row. I have more content in me than my siblings do.</div>
        <div>I'm an element that is block-like with my siblings and we're centered in a row.</div>
    </section>
    <div class="flex-ctr">
        <p>I'm vertically centered multiple lines of text in a flexbox container.</p>
    </div>
    <style>
        .ghost-center{width: 240px; height: 200px; margin: 20px; background: white; color:white;resize: vertical;overflow: auto;padding: 20px;}
        .ghost-center{position: relative;}
        .ghost-center:before{content:'';display: inline-block;height: 100%;vertical-align:middle;}
        .ghost-center p{display: inline-block; vertical-align:middle;width: 190px; background: black;padding: 20px;margin: 0;}
    </style>
    <div class="ghost-center">
        <p>I'm vertically centered multiple lines of text in a container. Centered with a ghost pseudo element</p>
    </div>
    <style>
        .parent{position: relative;background: white;width: 250px;height: 250px;margin: 20px;resize: vertical;overflow: auto;}
        .child{
            position: absolute;height: 100px;padding: 20px;top:50%;left:20px; right:20px; margin-top: -70px;background: black;color: white;
        }
    </style>
    <div class="parent">
        <div class="child">I'm a block-level element with a fixed height, centered vertically within my parent.</div>
    </div>
    <style>
        .transform{position: absolute;top:50%;transform: translateY(-50%);left:20px;right:20px;background: black;color: white;padding:20px;text-align: justify}
        #spanContainer{width: 100px; height: 100px; background: #ff0; position: absolute;}
    </style>
    <div class="parent">
        <div class="transform">I'm a block-level element with an unknown height, centered vertically within my parent.</div>
    </div>
    <div id="spanContainer"></div>
</body>
<script>
    // 分时函数
var arg = [];
for (var i = 0; i<=10; i++) {
    arg.push(i)
}

var renderFriendList = function(data) {
    for (var i = 0, l = data.length; i < l; i++ ) {
        var span = document.createElement('span');
        span.innerHTML = i;
        document.getElementById('spanContainer').appendChild(span);
    }
}
renderFriendList(arg);

// 单例模式
var Singleton = function(name) {
    this.name = name;
    this.instance = null;
}
Singleton.prototype.getName = function() {
    console.log(this.name);
}
Singleton.getInstance = function(name) {
    if (!this.instance) {
        this.instance = new Singleton(name)
    }
    return this.instance;
}
var a = Singleton.getInstance('sven1');
var b = Singleton.getInstance('sven2');
console.log(a, b);

// 透明的单例模式
var CreateDiv = (function() {
    var instance;
    var CreateDiv = function(html) {
        if (instance) {
            return instance;
        }
        this.html = html;
        this.init();
        return instance = this;
    }
    CreateDiv.prototype.init = function() {
        var div = document.createElement('div');
        div.innerHTML = this.html;
        document.body.appendChild(div);
    }
    return CreateDiv;
})()
var a = new CreateDiv('sven1');
var b = new CreateDiv('sven2');
console.log(a, b);

// 用代理实现单例模式
var createDiv = function(html) {
    this.html = html;
    this.init();
}
createDiv.prototype.init= function() {
    var div = document.createElement('div');
    div.innerHTML = this.html;
    document.body.appendChild(div);
}
var ProxySingletonCreateDiv = (function() {
    var instance;
    return function(html) {
        if (!instance) {
            instance = new createDiv(html);
        }
        return instance;
    }
})();
var a = new ProxySingletonCreateDiv('sven1');
var b = new ProxySingletonCreateDiv('sven2');
console.log(a, b);

// javascript中的单例模式
var user = (function() {
    var __name = 'sven',
        __age = 29;
    return {
        getUserInfo: function() {
            return __name + '-' + __age;
        }
    }
})();

var tween = {
    linear: function(t, b, c, d) {
        return c*t/d + b;
    },
    easeIn: function(t, b, c, d) {
        return c*(t/=d)*t+b;
    },
    strongEaseIn: function(t, b, c, d) {
        return c*(t/=d)*t*t*t*t+b;
    },
    strongEaseOut: function(t, b, c, d) {
        return c*((t/=d-1)*t*t*t*t+1)+b;
    },
    sineaseIn: function(t, b, c, d) {
        return c*(t/=d)*t*t + b;
    },
    sineaseOut: function(t, b, c, d) {
        return c*((t=t/d-1)*t*t + 1) + b;
    }
}
var Animate = function(dom) {
    this.dom = dom;
    this.startTime = 0;
    this.startPos = 0;
    this.endPos = 0;
    this.propertyName = null;
    this.easing = null;
    this.duration = null;
}
Animate.prototype.start = function(propertyName, endPos, duration, easing) {
    this.startTime = +new Date;
    this.startPos = this.dom.getBoundingClientRect()[propertyName];
    this.propertyName = propertyName;
    this.endPos = endPos;
    this.duration = duration;
    this.easing = tween[easing];

    var self = this;
    var timeId = setInterval(function() {
        if (self.step() === false) {  
            clearInterval(timeId);
        }
    }, 19);
}
Animate.prototype.step = function() {
    var t = +new Date;
    if (t >= this.startTime + this.duration) {
        this.update(this.endPos);
        return false;
    }
    var pos = this.easing(t - this.startTime, this.startPos, this.endPos - this.startPos, this.duration);
    this.update(pos);
}
Animate.prototype.update = function(pos) {
    this.dom.style[this.propertyName] = pos + 'px';
}
var div = document.getElementById('spanContainer');
var animate = new Animate(div);
animate.start('left', 500, 1000, 'strongEaseOut')
</script>
</html>